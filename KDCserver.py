import socket
import os
import random
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend

def encrypt_data_rsa(data, key):
    cipher = key.encrypt(
        data,
        padding.OAEP(
            mgf=padding.MGF1(algorithm=hashes.SHA256()),
            algorithm=hashes.SHA256(),
            label=None
        )
    )
    return cipher

def decrypt_data_rsa(data, key):
    cipher = key.decrypt(
        data,
        padding.OAEP(
            mgf=padding.MGF1(algorithm=hashes.SHA256()),
            algorithm=hashes.SHA256(),
            label=None
        )
    )
    return cipher

def encrypt_data_aes(data, key):
    cipher = Cipher(algorithms.AES(key), modes.ECB(), backend=default_backend())
    encryptor = cipher.encryptor()
    ct = encryptor.update(data) + encryptor.finalize()
    return ct

def decrypt_data_aes(data, key):
    cipher = Cipher(algorithms.AES(key), modes.ECB(), backend=default_backend())
    decryptor = cipher.decryptor()
    pt = decryptor.update(data) + decryptor.finalize()
    return pt

def main():
    CLIENT_3_ID = "HostKDC"
    KEY_STRING_1 = "key1"
    KEY_STRING_2 = "key2"
    KEY_STRING_3 = "key3"

    # Generate RSA key pair for server
    private_key = rsa.generate_private_key(
        public_exponent=65537,
        key_size=1024,
        backend=default_backend()
    )
    public_key = private_key.public_key()

    # AES key generator
    key_gen_aes = rsa.generate_private_key(
        public_exponent=65537,
        key_size=128,
        backend=default_backend()
    )

    # Open the server and initialize it as 3007
    port_number = 3007
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_socket:
        server_socket.bind(('', port_number))
        server_socket.listen()
        print("Server started and listening for connections...")

        # Connect to client 1
        client1_socket, client1_address = server_socket.accept()
        print("Client 1 connected:", client1_address)

        with client1_socket.makefile('wb', buffering=0) as d_out1, client1_socket.makefile('rb', buffering=0) as d_in1:
            # Read client 1's public key
            client1_public_key_length = int.from_bytes(d_in1.read(4), byteorder='big')
            client1_public_key_bytes = d_in1.read(client1_public_key_length)
            client1_public_key = serialization.load_pem_public_key(
                client1_public_key_bytes,
                backend=default_backend()
            )
            print("Client 1's public key:", client1_public_key)

            # Read client 1's ID
            client1_id = d_in1.readline().decode().strip()
            print("Client 1's ID:", client1_id)

            # Generate nonce and ID pair
            random_array1 = [random.randint(0, 1) for _ in range(16)]
            nonce1 = ''.join(map(str, random_array1))
            nonce_id_pair1 = nonce1 + "-" + CLIENT_3_ID
            print("HostKDC's nonce and ID:", nonce_id_pair1)

            # Encrypt nonce-ID pair with client 1's public key
            nonce_id_pair1_encrypted = encrypt_data_rsa(nonce_id_pair1.encode(), client1_public_key)

            # Send encrypted nonce-ID pair to client 1
            d_out1.write(len(nonce_id_pair1_encrypted).to_bytes(4, byteorder='big'))
            d_out1.write(nonce_id_pair1_encrypted)

            # Send server's public key to client 1
            d_out1.write(len(public_key.public_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PublicFormat.SubjectPublicKeyInfo
            )).to_bytes(4, byteorder='big'))
            d_out1.write(public_key.public_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PublicFormat.SubjectPublicKeyInfo
            ))

            # Receive encrypted package with two nonces
            encrypted_double_nonce1_length = int.from_bytes(d_in1.read(4), byteorder='big')
            encrypted_double_nonce1 = d_in1.read(encrypted_double_nonce1_length)

            # Decrypt package using the server private key into the two nonces
            double_nonce1_bytes = decrypt_data_rsa(encrypted_double_nonce1, private_key)
            double_nonce1 = double_nonce1_bytes.decode().split("-")
            client1_nonce_client = double_nonce1[0]
            client1_nonce_server = double_nonce1[1]
            print("Client 1 nonce generated by client:", client1_nonce_client)
            print("Host nonce generated by server:", client1_nonce_server)

            # Check if the received nonce matches the server generated nonce
            if not client1_nonce_server == nonce1:
                raise ValueError("Error: the received nonce does not match with the server generated nonce!")

            # Send host generated nonce encrypted with client1 public key back to client 1
            encrypted_client1_nonce_client = encrypt_data_rsa(nonce1.encode(), client1_public_key)
            d_out1.write(len(encrypted_client1_nonce_client).to_bytes(4, byteorder='big'))
            d_out1.write(encrypted_client1_nonce_client)

            # Generate symmetric key for client 1
            symmetric_key1 = os.urandom(16)
            print("Client 1 symmetric key:", symmetric_key1)

            # Encrypt symmetric key with server's private key
            encrypted_symmetric_key1 = encrypt_data_rsa(symmetric_key1, private_key)

            # Use client 1's public key to doubly encrypt the package
            encrypted_symmetric_key1_front = encrypted_symmetric_key1[:64]
            encrypted_symmetric_key1_back = encrypted_symmetric_key1[64:]
            doubly_encrypted_symmetric_key1_front = encrypt_data_rsa(encrypted_symmetric_key1_front, client1_public_key)
            doubly_encrypted_symmetric_key1_back = encrypt_data_rsa(encrypted_symmetric_key1_back, client1_public_key)

            # Send both packet halves to client 1
            d_out1.write(len(doubly_encrypted_symmetric_key1_front).to_bytes(4, byteorder='big'))
            d_out1.write(doubly_encrypted_symmetric_key1_front)
            d_out1.write(len(doubly_encrypted_symmetric_key1_back).to_bytes(4, byteorder='big'))
            d_out1.write(doubly_encrypted_symmetric_key1_back)

        # Connect to client 2
        client2_socket, client2_address = server_socket.accept()
        print("Client 2 connected:", client2_address)

        with client2_socket.makefile('wb', buffering=0) as d_out2, client2_socket.makefile('rb', buffering=0) as d_in2:
            # Read client 2's public key
            client2_public_key_length = int.from_bytes(d_in2.read(4), byteorder='big')
            client2_public_key_bytes = d_in2.read(client2_public_key_length)
            client2_public_key = serialization.load_pem_public_key(
                client2_public_key_bytes,
                backend=default_backend()
            )
            print("Client 2's public key:", client2_public_key)

            # Read client 2's ID
            client2_id = d_in2.readline().decode().strip()
            print("Client 2's ID:", client2_id)

            # Generate nonce and ID pair
            random_array2 = [random.randint(0, 1) for _ in range(16)]
            nonce2 = ''.join(map(str, random_array2))
            nonce_id_pair2 = nonce2 + "-" + CLIENT_3_ID
            print("HostKDC's nonce and ID:", nonce_id_pair2)

            # Encrypt nonce-ID pair with client 2's public key
            nonce_id_pair2_encrypted = encrypt_data_rsa(nonce_id_pair2.encode(), client2_public_key)

            # Send encrypted nonce-ID pair to client 2
            d_out2.write(len(nonce_id_pair2_encrypted).to_bytes(4, byteorder='big'))
            d_out2.write(nonce_id_pair2_encrypted)

            # Send the server's public key to client 2
            d_out2.write(len(public_key.public_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PublicFormat.SubjectPublicKeyInfo
            )).to_bytes(4, byteorder='big'))
            d_out2.write(public_key.public_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PublicFormat.SubjectPublicKeyInfo
            ))

            # Receive encrypted package with two nonces
            encrypted_double_nonce2_length = int.from_bytes(d_in2.read(4), byteorder='big')
            encrypted_double_nonce2 = d_in2.read(encrypted_double_nonce2_length)

            # Decrypt package using the server private key into the two nonces
            double_nonce2_bytes = decrypt_data_rsa(encrypted_double_nonce2, private_key)
            double_nonce2 = double_nonce2_bytes.decode().split("-")
            client2_nonce_client = double_nonce2[0]
            client2_nonce_server = double_nonce2[1]
            print("Client 2 nonce generated by client:", client2_nonce_client)
            print("Host nonce generated by server:", client2_nonce_server)

            # Check if the received nonce matches the server generated nonce
            if not client2_nonce_server == nonce2:
                raise ValueError("Error: the received nonce does not match with the server generated nonce!")

            # Send host generated nonce encrypted with client2 public key back to client 2
            encrypted_client2_nonce_client = encrypt_data_rsa(nonce2.encode(), client2_public_key)
            d_out2.write(len(encrypted_client2_nonce_client).to_bytes(4, byteorder='big'))
            d_out2.write(encrypted_client2_nonce_client)

            # Generate symmetric key for client 2
            symmetric_key2 = os.urandom(16)
            print("Client 2 symmetric key:", symmetric_key2)

            # Encrypt symmetric key with server's private key
            encrypted_symmetric_key2 = encrypt_data_rsa(symmetric_key2, private_key)

            # Use client 2's public key to doubly encrypt the package
            encrypted_symmetric_key2_front = encrypted_symmetric_key2[:64]
            encrypted_symmetric_key2_back = encrypted_symmetric_key2[64:]
            doubly_encrypted_symmetric_key2_front = encrypt_data_rsa(encrypted_symmetric_key2_front, client2_public_key)
            doubly_encrypted_symmetric_key2_back = encrypt_data_rsa(encrypted_symmetric_key2_back, client2_public_key)

            # Send both packet halves to client 2
            d_out2.write(len(doubly_encrypted_symmetric_key2_front).to_bytes(4, byteorder='big'))
            d_out2.write(doubly_encrypted_symmetric_key2_front)
            d_out2.write(len(doubly_encrypted_symmetric_key2_back).to_bytes(4, byteorder='big'))
            d_out2.write(doubly_encrypted_symmetric_key2_back)

        # PHASE 2
        # Read IDs from request
        request = client1_socket.recv(1024).decode().strip()
        IDs = request.split("-")
        IDa = IDs[0]
        IDb = IDs[1]
        print("A's ID:", IDa)
        print("B's ID:", IDb)

        # Generate the Kab
        session_key = os.urandom(16)
        print("Session key between both clients A and B:", session_key)

        # Encrypt the Kab
        encrypted_kab_with_ka = encrypt_data_aes(session_key, symmetric_key1)
        encrypted_kab_with_kb = encrypt_data_aes(session_key, symmetric_key2)

        # Send
        client1_socket.sendall(len(encrypted_kab_with_ka).to_bytes(4, byteorder='big'))
        client1_socket.sendall(encrypted_kab_with_ka)
        client2_socket.sendall(len(encrypted_kab_with_kb).to_bytes(4, byteorder='big'))
        client2_socket.sendall(encrypted_kab_with_kb)

if __name__ == "__main__":
    main()
